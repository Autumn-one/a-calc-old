# a-calc
[![Static Badge](https://img.shields.io/badge/a--calc-1.3.12-green?style=flat)](https://github.com/Autumn-one/a-calc-old) [![Static Badge](https://img.shields.io/badge/Javascript-5A5A5A?style=flat&logo=javascript&link=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fa-calc)](https://github.com/Autumn-one/a-calc-old) [![Static Badge](https://img.shields.io/badge/Typescript-5A5A5A?style=flat&logo=typescript&logoColor=F7DF1E&link=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fa-calc)](https://github.com/Autumn-one/a-calc-old)

来源于实际业务的数字字符串四则运算的库, 可解决以下问题:

* 体积：未压缩体积56KB 。gzip压缩体积18KB
* js数字计算精度问题
* 其他第三方库编码体验差且格式化不够方便
* 数字计算可能输出科学计数法
* 数字格式化, 数字千分位输出, 数字直接格式化成百分比, 保留数字的正负号, 直接输出分数等
* 带单位的数字计算或格式化, 例如: `0.1% + 2% `
* 科学计数法写法的计算, 例如:`-2e3 + 6`
* 支持四种舍入规则：去尾、进一、四舍五入、四舍六入(一种更精准的方法)

> 支持的运算符 :  + - * / % ** 

**Language：** 简体中文 | [英文](https://www.npmjs.com/package/a-calc)

## 安装

```
npm install a-calc
```

## 引入

**commonjs**

```js
const {calc, fmt} = require("a-calc")
// 或者
const {calc, fmt} = require("a-calc/cjs") // 注意这个写法是明确指定使用cjs版本, 有些打包工具会对语法做转换, 直接写 a-calc 不好使, 那就换成 a-calc/cjs 试试
```

**es module**

```js
import {calc, fmt} from "a-calc"
// 或者
const {calc, fmt} from "a-calc/es"
```

**browser**

```html
<script src="node_modules/a-calc/browser/index.js"></script>
<script>
const {calc, fmt} = a_calc
</script>
```

## 四则运算(支持科学计数法写法)

```js
calc("0.1 + 0.2") // 0.3

// 复杂一点的计算
calc("0.1 + 0.2 * 0.3 / 0.4 * (0.5 + 0.6)") // 0.265

// 科学计数法的计算
calc("-2e2 + 3e+2") // 100
```

## 关于空格

空格在无歧义的情况下是非必须的，甚至可以正确解析下面人眼都难以解析的写法`calc("-2e+2+3e+2")`，但是这样清晰度太低了，请尽其所能写更清晰的代码而不是shit！<span style="color: red;">始终在你的计算式包含空格，这样更漂亮和清晰，就像我写的示例那样！！！</span>

顺便举个有歧义的计算式 `calc("50%%2", {_unit: true})`这种歧义显然是在带单位计算的时候出现，由于解析器不知道你的单位是`%` 还是 `%%` 所以你要用空格给出明确的意思，正确的写法应该是 `calc("50% % 2", {_unit: true})` 

总之始终加空格！

## 填充变量并计算(重要)

**计算后的值为精准值且不会出现科学计数法**

```js
let a = 0.000001
let b = 888.789
calc("a + b", {a,b}) // 0.000001 + 888.789 = 888.789001

calc("a * (b + c) % d + 7.123", [
    {a: 1, b: 2},
    {c: 3, d: 4}
]) // 8.123

// 复杂一点的
calc("1 + o.a / arr[0].d",{
    o: { a: 2 },
    arr: [{ d: 8 }]
}) // 1.25

calc("a + b - c",[
    {a: 1},
    {b: 2, c: 3}
])
```

## 带单位的计算

> 实际情况不总是那么理想, 也许我们不得不计算两个百分比数字, 幸好现在a-calc支持这些操作, 但是请注意,单位会从第一个携带单位的数字上取, 后面的单位会被忽略

```js
// 要特别注意 _unit是必须的, 且不是默认开启的, 这是因为带单位的计算会额外做一些操作, 相比之下单纯的数字计算更快
calc("1 + 2%", {_unit: true}) // 3%

calc("1.123$$$ + 2.88% | + =6", {_unit: true}) // +4.003000$$$
```

在 `1.0.6` 之后带单位的计算可以有更多的参数，`_unit` 的取值可以为`boolean | "on" | "off" | "auto" | "space"` 参数看起来很多其实和之前的用法差不多， `true "on" "auto"` 这三个值的效果是一样的，表示自动识别数字后的单位，`false "off"` 表示关闭单位计算，最大的不同是 `"space"` 这个值表示只将空格作为单位分隔符，例如你的单位恰好是 `+-` 这种情况在普通模式下会被识别成运算符，就可以使用 `"space"` 模式，但是此时的空格就是必须的了，你要这样写：`calc("2+- * 3")` 最终结果为：`6+-`



实际开发中你可能希望最终的结果不要自动携带单位，在 `1.3.6` 之后的版本可以通过格式化参数 `!u` 去除结果中的单位，或者 `!n` 直接输出数字。

## 计算并格式化

格式化支持如下功能：限制小数位数，保留正负号，百分比输出，科学计数法输出，千分位输出，并且他们是可以组合的，不过有个别的情况组合是不生效的，这个自己去试一下，组合情况太多，不在一一列举。

**格式化列表：**

- `>|>=|<|<=|=数字` 表示限制小数位数，例: `<=2` 小数位数小于等于2 `>3` 小数位数必须大于3，这个等价于`>=4`
- `,` 输出为千分位数字字符串
- `/` 输出为分数
- `+` 输出的正数带`+` 号
- `%` 输出百分比数字，可以和限制小数组合使用
- `!e` 输出为科学计数法，e可以大写
- `!n` 输出为数字而不是数字字符串，n可以大写，1.3.6版本之后这个优先级为最高，任何其他的格式化参数无法影响该参数。
- `!u` 从结果中去除单位

```js
// 操作小数位数
calc("0.1 + 0.2 | =2") // 0.30
calc("0.11111 + 0.11111 | <=4") // 0.2222
calc("0.11 + 0.11 | <=4") // 0.22
calc("0.1 + 0.2 | >= 5") // 0.30000
calc("0.0000001+ 0.0000001 | >= 5") // 0.0000002

// 保留正负号
calc("1 + 1 | +") // +2

// 千分位
calc("10000000 + 100000000 | ,") // 110,000,000

// 分数
calc("0.025 + 0.2 | /") // 9/40

// 百分比
calc("1 + 1 | %") // 200%

// 科学计数法, 注意这个 e也可以大写
calc("1 + 1 | !e") // 2e+0

// 同时指定小数位和千分位且保留正负号
calc("10000000 + 100000000 | +,=10") // +110,000,000.0000000000
```

## 四种舍入规则

舍入规则通过在格式化字符串的部分加入，他们的符号分别为:

- `~-` 去尾，默认的舍入规则
- `~+` 进一
- `~5` 四舍五入
- `~6` 四舍六入，该舍入规则相较四舍五入更为精准，规则在舍入的后一位为5的时候有所不同，他会查看5后面的位置，如果后面的数字不为0那么会进一，如果后面的数字为0 ，那么会看5前面的数字是否为偶数，如果是则不进，不是则进

```js
calc("0.11 + 0.22 | =1 ~+") // 0.4 保留一位并进一
calc("0.55 | =1 ~5") // 0.6
calc("0.65 | =1 ~6") // 0.6
```

这个新加入的舍入规则似乎会让格式化的部分更加的长，但是实际情况不是这样，一般一个项目的舍入规则是固定的，所以舍入规则部分的格式化应该被封装在默认的格式化参数中，在实际使用的时候完全不需要书写这部分内容，参考下面的`默认格式化` 说明

## 只格式化

```js
calc("0.1 | =2") // 0.10
fmt("0.1 | =2") // 0.10
// calc 具备 fmt 的功能, 但是fmt具备更好的语义

fmt("1000000 | ,") // 1,000,000
```

## 配置版本号打印和库更新检测

你可以开启或关闭控制台打印当前库的版本号，也可以开启或关闭控制台提示当前是否有新的版本更新。

```typescript
import { calc_util } from "a-calc"
calc_util.print_version(); // 在控制台打印版本
calc_util.check_update(); // 开启检测更新功能，如果有更新会在控制台提醒
```

## 高级技巧

**错误处理**

> 通常直接使用calc做计算要求输入的计算式是完全正确的, 默认 a-calc 不会帮你处理计算式的错误, 这个可以自己做过滤, 但在项目里我们可能不想做这件事情那么就需要额外的高级API, 在输入的计算式有误的时候静默捕获并给出一个合适的返回值

```js
calc("1 + 2sd + d",{
    _fill_data: {d: 3}, // 从这里数据源对象要赋给 _fill_data, 该对象也可以是一个对象数组,此时取数据的时候是依次从数组的项里查找,找到第一个立刻停止
    _error: "-", // 计算式出错的时候返回 - 作为替代值
})

// 上面的写法可以简化一下
calc("1 + 2sd + d", {
    d: 8,
    _error: "-"
}) // 这种简化单纯是为了方便
```

**默认格式化**

> 在实际项目中可以利用默认格式化优化开发体验

```js
calc("111111 + 11111 | ,",{_fmt: "=2"}) // 122,222.00 很显然 , 和 =2 被组合起来了,且表达式中的格式化字符串优先级更高
```

## 怎样在项目中二次封装？

在实际的项目中核心的 `calc` 函数可能还不够极致的便捷，因此`a-calc` 在 `1.2.10` 版本之后提供了一个内置的二次封装的函数`calc_wrap`，它本质是 `calc` 的扩展，所以它拥有所有前者的功能只是多了更多灵活的写法，和强大的类型推导。

注意这也许不是唯一正确的封装方式，我只是提供了这个功能而已，这里没有教条，你应该灵活应对你自己的场景。

我建议如果决定将 `calc_wrap` 引入项目，那么你可以将其重命名为 `calc` 这样可以少写几个字符，下面将展示一些灵活的写法和强大的类型推导。

```typescript
// 注意这里将 calc_wrap 重命名为 calc, 因为如果你需要使用 calc_wrap 函数的时候，基本用不到核心的 calc 函数，那么有这个闲置好名字就应该拿来用
import { calc_wrap as calc } from "a-calc";

const state = {
    a: 1,
    b: 2,
    c: 3
};

// 当传入的参数是一个不含变量名的计算式将会直接返回计算结果
calc( "(1 + 2) * 3" ); // 返回类型: string

// 当传入的参数是一个疑似包含变量名的计算式且没有第二个数据源参数时，会返回一个等待传入数据源的函数，没错这个功能通过静态类型的推导做到了
calc( "(a + b) * c" ); // 返回类型: ( data: any ) => string
calc( "(a + b) * c" )( state ); // 返回类型: string

// 也许你希望先注入状态然后在输入表达式，这也是可以的
calc( state ); // 返回类型: ( expr: string | number ) => string
calc( state )( "(a + b) * c" ); // 返回类型: string

// 原本的用法自然也是支持的
calc( "a + b + c", state ); // 返回类型: string

// 你依然可以将配置与数据源混合在一起，这是非常方便的
calc( "a + b + c" )( { ...state, _error: 0 } ); // 返回类型: string | 0
```

### 不推荐的写法

`a-calc` 可以使用模板字符串写法, 但是我在实践中发现这种写法的可读性很糟糕，除非你真的有足够合理的理由，不然不建议使用模板字符串的写法。

```typescript
calc(`${a} + ${b}`) // 这种写法不推荐
calc("a + b", {a,b}) // 推荐写法，因为更清晰
```



## 版本变更

* 1.3.9 解决格式化部分注入变量为0时导致的取整失败（问题反馈人：MangMax）
* 1.3.8 解决由于 vite5.x 的升级导致的打包失败问题（问题反馈人：武建鹏）
* 1.3.6
    - `!n` 格式化参数优先级调整为最高，任何其他格式化参数无法影响它。
    - 新增`!u`格式化参数，可以去除结果中的单位部分
    - 类型提示增强
* 1.3.4
    - 解决四舍五入与四舍六入舍入错误的bug（bug提供者: nanarino）
* 1.3.0
    - 破环性变更：调整版本号打印功能和检测更新功能的调用方式
    - 完善类型提示
    - 添加更多的单元测试
* 1.2.30
    - 之前的版本默认会在控制打印版本号，现在它是可配置的，而且默认关闭
    - 提供了检测更新功能，开启之后如果有新版本会在控制台给出提示
* 1.2.10
    - 删除vue集成示例，该库本身不于某个前端框架绑定，为避免误解，删除对应集成代码。
    - 增加 `calc_wrap` 功能，该函数是对核心函数 `calc` 的二次封装，可以拿来直接使用。
* 1.2.6
    - 调整vue3集成代码，由于vue3的组件实例在开发环境和生成环境有所不同，所以生产环境无法获取state，但是开发环境可以获取。
* 1.2.0
    - 很小的破坏性更新， 以前的`-e` 和 `-n` 分别变成 `!e` 和 `!n`
    - 文档更新
* 1.1.0
    - 很小的破环性更新，以前的 `\e` 科学计数法输出，现在是 `-e`，其他没变
    - 增加了 `-n` 输出数字类型
    - 对于小数位的限制支持了 `<` 和 `>` 符号
    - 修复了若干舍入格式化问题
    - 单元测试增加到107个
* 1.0.25
    - 文档更新，简化 a-calc 集成到vue3的写法
* 1.0.23
    - 文档更新，重新编写将a-calc集成到vue3的推荐写法
* 1.0.22
    - 优化小数位舍入逻辑
* 1.0.21
    - 完善导出的类型定义
* 1.0.19
    - 修复 _error 为空字符串的时候可能无法捕获错误的问题
* 1.0.14
    - 修复 ** 运算符优先级错误的问题。
    - 对于 `<=` 格式化时可能会有多余的0未去除的问题进行修复。
* 1.0.12
    - 文档添加库体积说明
    - 修复表达式为空的时候加上 _error 参数依然异常的问题， 并添加相应的单元测试
* 1.0.10
    - 更新文档
* 1.0.6
    * 破坏性变更：所有暴露出的小驼峰命名全部改成了蛇形命名法例如原来的`_fillData` 现在变成了 `_fill_data`，原因是蛇形命名法更清晰。
    * 内部代码极大的简化，解析器几乎完全重写，带来更稳定的体验
    * 原先的设计就是calc函数具备所有fmt的功能，可是1.0.6之前的版本虽然符合这个设计，但calc和fmt是分别实现的，现在fmt只是calc的别名。
    * 支持新的运算符 **
    * 支持新的格式化字符 % 可以将数字输出成百分比
    * 支持新的格式化字符 `\e`，可以将数字格式化成科学计数法
    * 修复格式化字符串非法的时候可能造成死循环的问题
    * 解决1/0是 Infinity 的问题
    * 增加若干单元测试
    * 更详细的类型提示
    * 更新文档，添加vue3集成的示例代码
* 0.0.80
    * 带来4种舍入规则，分别为：去尾、进一、四舍五入、四舍六入
    * 更多边界情况的检测
    * fmt允许不传入格式化字符串，这个特性允许你使用 fmt 来清除小数点后多余的0
* 0.0.79 
    * 更新文档
* 0.0.78
    * 支持科学计数法的计算
    * 完整的单元测试
    * 更多边界情况的检测
* 0.0.72
    * 支持单个数值的带单位写法, 例如 `calc("1元", {_unit: true})` 或者 `fmt("1元 | =2",{_unit: true})`
    * 补充文档

## 注意

- 不要对单个数字包裹括号

## 视频教程

待定

## 问题提交

反馈问题请携带错误案例和尽可能多的问题信息，请勿发一句极其抽象与概括的话当做问题反馈！你未提供的信息我不能通过预测获得。通常工作日一天内会发布新版修复问题。



